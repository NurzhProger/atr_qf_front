import { DOCUMENT, isPlatformBrowser } from '@angular/common';
import { Inject, Injectable, Optional, PLATFORM_ID } from '@angular/core';
import { from, fromEvent, merge, NEVER, throwError } from 'rxjs';
import { map, switchMap, take } from 'rxjs/operators';
import { YA_CONFIG } from '../../tokens/ya-config';
import * as i0 from "@angular/core";
/**
 * The `YaApiLoader` service handles loading of Yandex.Maps API.
 *
 * @example
 * ```ts
 * import { YaApiLoaderService } from 'angular8-yandex-maps';
 *
 * @Component()
 * export class AppComponent {
 *   constructor(private yaApiLoaderService: YaApiLoaderService) {
 *     // Don't forget to unsubscribe
 *     this.yaApiLoaderService.load()
 *       .subscribe(v => console.log(v))
 *   }
 * }
 *```
 *
 * @dynamic
 */
export class YaApiLoaderService {
    constructor(config, document, platformId) {
        this.document = document;
        this.isBrowser = isPlatformBrowser(platformId);
        const defaultConfig = { lang: 'ru_RU' };
        this.config = {
            ...defaultConfig,
            ...config,
        };
    }
    /**
     * Loads Yandex.Maps API.
     */
    load() {
        if (!this.isBrowser) {
            return NEVER;
        }
        if (window.ymaps) {
            return from(ymaps.ready()).pipe(map(() => ymaps));
        }
        if (!this.script) {
            const script = this.document.createElement('script');
            script.type = 'text/javascript';
            script.src = this.getScriptSource(this.config);
            script.id = 'yandexMapsApiScript';
            script.async = true;
            script.defer = true;
            this.script = this.document.body.appendChild(script);
        }
        const load = fromEvent(this.script, 'load').pipe(switchMap(() => from(ymaps.ready())), map(() => ymaps));
        const error = fromEvent(this.script, 'error').pipe(switchMap(throwError));
        return merge(load, error).pipe(take(1));
    }
    /**
     * Returns script source by config.
     * @param config config with parameters that will be added in source
     * @example
     * // returns 'https://api-maps.yandex.ru/2.1/?apikey=658f67a2-fd77-42e9-b99e-2bd48c4ccad4&lang=en_US'
     * getScriptSource({ apikey: '658f67a2-fd77-42e9-b99e-2bd48c4ccad4', lang: 'en_US' })
     */
    getScriptSource(config) {
        const { enterprise, version = '2.1', ...rest } = config;
        const params = this.convertConfigIntoQueryParams(rest);
        return `https://${enterprise ? 'enterprise.' : ''}api-maps.yandex.ru/${version}/?${params}`;
    }
    /**
     * Converts a config into a query string parameters.
     * @param config object for converting
     * @example
     * // returns "lang=ru_RU&apikey=XXX"
     * convertIntoQueryParams({ lang: 'ru_RU', apikey: 'XXX' })
     */
    convertConfigIntoQueryParams(config) {
        return Object.entries(config)
            .map(([key, value]) => `${key}=${value}`)
            .join('&');
    }
}
YaApiLoaderService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.5", ngImport: i0, type: YaApiLoaderService, deps: [{ token: YA_CONFIG, optional: true }, { token: DOCUMENT }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });
YaApiLoaderService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.5", ngImport: i0, type: YaApiLoaderService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.5", ngImport: i0, type: YaApiLoaderService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [YA_CONFIG]
                }] }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWEtYXBpLWxvYWRlci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhcjgteWFuZGV4LW1hcHMvc3JjL2xpYi9zZXJ2aWNlcy95YS1hcGktbG9hZGVyL3lhLWFwaS1sb2FkZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDOUQsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFdBQVcsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMxRSxPQUFPLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFjLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM3RSxPQUFPLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUd0RCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sd0JBQXdCLENBQUM7O0FBRW5EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FrQkc7QUFJSCxNQUFNLE9BQU8sa0JBQWtCO0lBTzdCLFlBQ2lDLE1BQXVCLEVBQ25CLFFBQWtCLEVBQ2hDLFVBQWtCO1FBREosYUFBUSxHQUFSLFFBQVEsQ0FBVTtRQUdyRCxJQUFJLENBQUMsU0FBUyxHQUFHLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRS9DLE1BQU0sYUFBYSxHQUFhLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxDQUFDO1FBRWxELElBQUksQ0FBQyxNQUFNLEdBQUc7WUFDWixHQUFHLGFBQWE7WUFDaEIsR0FBRyxNQUFNO1NBQ1YsQ0FBQztJQUNKLENBQUM7SUFFRDs7T0FFRztJQUNILElBQUk7UUFDRixJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNuQixPQUFPLEtBQUssQ0FBQztTQUNkO1FBRUQsSUFBSSxNQUFNLENBQUMsS0FBSyxFQUFFO1lBQ2hCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUNuRDtRQUVELElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2hCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRXJELE1BQU0sQ0FBQyxJQUFJLEdBQUcsaUJBQWlCLENBQUM7WUFDaEMsTUFBTSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUMvQyxNQUFNLENBQUMsRUFBRSxHQUFHLHFCQUFxQixDQUFDO1lBQ2xDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO1lBQ3BCLE1BQU0sQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO1lBRXBCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ3REO1FBRUQsTUFBTSxJQUFJLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUM5QyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEVBQ3BDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FDakIsQ0FBQztRQUVGLE1BQU0sS0FBSyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztRQUUxRSxPQUFPLEtBQUssQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSyxlQUFlLENBQUMsTUFBZ0I7UUFDdEMsTUFBTSxFQUFFLFVBQVUsRUFBRSxPQUFPLEdBQUcsS0FBSyxFQUFFLEdBQUcsSUFBSSxFQUFFLEdBQUcsTUFBTSxDQUFDO1FBQ3hELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUV2RCxPQUFPLFdBQVcsVUFBVSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLEVBQUUsc0JBQXNCLE9BQU8sS0FBSyxNQUFNLEVBQUUsQ0FBQztJQUM5RixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ssNEJBQTRCLENBQUMsTUFBZ0I7UUFDbkQsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQzthQUMxQixHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7YUFDeEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2YsQ0FBQzs7K0dBakZVLGtCQUFrQixrQkFRUCxTQUFTLDZCQUNyQixRQUFRLGFBQ1IsV0FBVzttSEFWVixrQkFBa0IsY0FGakIsTUFBTTsyRkFFUCxrQkFBa0I7a0JBSDlCLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25COzswQkFTSSxRQUFROzswQkFBSSxNQUFNOzJCQUFDLFNBQVM7OzBCQUM1QixNQUFNOzJCQUFDLFFBQVE7OzBCQUNmLE1BQU07MkJBQUMsV0FBVyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPQ1VNRU5ULCBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgT3B0aW9uYWwsIFBMQVRGT1JNX0lEIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IGZyb20sIGZyb21FdmVudCwgbWVyZ2UsIE5FVkVSLCBPYnNlcnZhYmxlLCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IG1hcCwgc3dpdGNoTWFwLCB0YWtlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuaW1wb3J0IHsgWWFDb25maWcgfSBmcm9tICcuLi8uLi9tb2RlbHMveWEtY29uZmlnJztcclxuaW1wb3J0IHsgWUFfQ09ORklHIH0gZnJvbSAnLi4vLi4vdG9rZW5zL3lhLWNvbmZpZyc7XHJcblxyXG4vKipcclxuICogVGhlIGBZYUFwaUxvYWRlcmAgc2VydmljZSBoYW5kbGVzIGxvYWRpbmcgb2YgWWFuZGV4Lk1hcHMgQVBJLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0c1xyXG4gKiBpbXBvcnQgeyBZYUFwaUxvYWRlclNlcnZpY2UgfSBmcm9tICdhbmd1bGFyOC15YW5kZXgtbWFwcyc7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoKVxyXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcclxuICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIHlhQXBpTG9hZGVyU2VydmljZTogWWFBcGlMb2FkZXJTZXJ2aWNlKSB7XHJcbiAqICAgICAvLyBEb24ndCBmb3JnZXQgdG8gdW5zdWJzY3JpYmVcclxuICogICAgIHRoaXMueWFBcGlMb2FkZXJTZXJ2aWNlLmxvYWQoKVxyXG4gKiAgICAgICAuc3Vic2NyaWJlKHYgPT4gY29uc29sZS5sb2codikpXHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqYGBgXHJcbiAqXHJcbiAqIEBkeW5hbWljXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSh7XHJcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgWWFBcGlMb2FkZXJTZXJ2aWNlIHtcclxuICBwcml2YXRlIHJlYWRvbmx5IGlzQnJvd3NlcjogYm9vbGVhbjtcclxuXHJcbiAgcHJpdmF0ZSByZWFkb25seSBjb25maWc6IFlhQ29uZmlnO1xyXG5cclxuICBwcml2YXRlIHNjcmlwdDogSFRNTFNjcmlwdEVsZW1lbnQ7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChZQV9DT05GSUcpIGNvbmZpZzogWWFDb25maWcgfCBudWxsLFxyXG4gICAgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSByZWFkb25seSBkb2N1bWVudDogRG9jdW1lbnQsXHJcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwbGF0Zm9ybUlkOiBvYmplY3QsXHJcbiAgKSB7XHJcbiAgICB0aGlzLmlzQnJvd3NlciA9IGlzUGxhdGZvcm1Ccm93c2VyKHBsYXRmb3JtSWQpO1xyXG5cclxuICAgIGNvbnN0IGRlZmF1bHRDb25maWc6IFlhQ29uZmlnID0geyBsYW5nOiAncnVfUlUnIH07XHJcblxyXG4gICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgIC4uLmRlZmF1bHRDb25maWcsXHJcbiAgICAgIC4uLmNvbmZpZyxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMb2FkcyBZYW5kZXguTWFwcyBBUEkuXHJcbiAgICovXHJcbiAgbG9hZCgpOiBPYnNlcnZhYmxlPHR5cGVvZiB5bWFwcz4ge1xyXG4gICAgaWYgKCF0aGlzLmlzQnJvd3Nlcikge1xyXG4gICAgICByZXR1cm4gTkVWRVI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHdpbmRvdy55bWFwcykge1xyXG4gICAgICByZXR1cm4gZnJvbSh5bWFwcy5yZWFkeSgpKS5waXBlKG1hcCgoKSA9PiB5bWFwcykpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5zY3JpcHQpIHtcclxuICAgICAgY29uc3Qgc2NyaXB0ID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcclxuXHJcbiAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XHJcbiAgICAgIHNjcmlwdC5zcmMgPSB0aGlzLmdldFNjcmlwdFNvdXJjZSh0aGlzLmNvbmZpZyk7XHJcbiAgICAgIHNjcmlwdC5pZCA9ICd5YW5kZXhNYXBzQXBpU2NyaXB0JztcclxuICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcclxuICAgICAgc2NyaXB0LmRlZmVyID0gdHJ1ZTtcclxuXHJcbiAgICAgIHRoaXMuc2NyaXB0ID0gdGhpcy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbG9hZCA9IGZyb21FdmVudCh0aGlzLnNjcmlwdCwgJ2xvYWQnKS5waXBlKFxyXG4gICAgICBzd2l0Y2hNYXAoKCkgPT4gZnJvbSh5bWFwcy5yZWFkeSgpKSksXHJcbiAgICAgIG1hcCgoKSA9PiB5bWFwcyksXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGVycm9yID0gZnJvbUV2ZW50KHRoaXMuc2NyaXB0LCAnZXJyb3InKS5waXBlKHN3aXRjaE1hcCh0aHJvd0Vycm9yKSk7XHJcblxyXG4gICAgcmV0dXJuIG1lcmdlKGxvYWQsIGVycm9yKS5waXBlKHRha2UoMSkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBzY3JpcHQgc291cmNlIGJ5IGNvbmZpZy5cclxuICAgKiBAcGFyYW0gY29uZmlnIGNvbmZpZyB3aXRoIHBhcmFtZXRlcnMgdGhhdCB3aWxsIGJlIGFkZGVkIGluIHNvdXJjZVxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogLy8gcmV0dXJucyAnaHR0cHM6Ly9hcGktbWFwcy55YW5kZXgucnUvMi4xLz9hcGlrZXk9NjU4ZjY3YTItZmQ3Ny00MmU5LWI5OWUtMmJkNDhjNGNjYWQ0Jmxhbmc9ZW5fVVMnXHJcbiAgICogZ2V0U2NyaXB0U291cmNlKHsgYXBpa2V5OiAnNjU4ZjY3YTItZmQ3Ny00MmU5LWI5OWUtMmJkNDhjNGNjYWQ0JywgbGFuZzogJ2VuX1VTJyB9KVxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0U2NyaXB0U291cmNlKGNvbmZpZzogWWFDb25maWcpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgeyBlbnRlcnByaXNlLCB2ZXJzaW9uID0gJzIuMScsIC4uLnJlc3QgfSA9IGNvbmZpZztcclxuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuY29udmVydENvbmZpZ0ludG9RdWVyeVBhcmFtcyhyZXN0KTtcclxuXHJcbiAgICByZXR1cm4gYGh0dHBzOi8vJHtlbnRlcnByaXNlID8gJ2VudGVycHJpc2UuJyA6ICcnfWFwaS1tYXBzLnlhbmRleC5ydS8ke3ZlcnNpb259Lz8ke3BhcmFtc31gO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgYSBjb25maWcgaW50byBhIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzLlxyXG4gICAqIEBwYXJhbSBjb25maWcgb2JqZWN0IGZvciBjb252ZXJ0aW5nXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAvLyByZXR1cm5zIFwibGFuZz1ydV9SVSZhcGlrZXk9WFhYXCJcclxuICAgKiBjb252ZXJ0SW50b1F1ZXJ5UGFyYW1zKHsgbGFuZzogJ3J1X1JVJywgYXBpa2V5OiAnWFhYJyB9KVxyXG4gICAqL1xyXG4gIHByaXZhdGUgY29udmVydENvbmZpZ0ludG9RdWVyeVBhcmFtcyhjb25maWc6IFlhQ29uZmlnKTogc3RyaW5nIHtcclxuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhjb25maWcpXHJcbiAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fT0ke3ZhbHVlfWApXHJcbiAgICAgIC5qb2luKCcmJyk7XHJcbiAgfVxyXG59XHJcbiJdfQ==