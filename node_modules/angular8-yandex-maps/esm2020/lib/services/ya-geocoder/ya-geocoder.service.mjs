import { Injectable } from '@angular/core';
import { from, Observable } from 'rxjs';
import { switchMap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "../ya-api-loader/ya-api-loader.service";
/**
 * The `YaGeocoder` service wraps `ymaps.geocode` static function from the Yandex.Maps API.
 *
 * @example
 * ```ts
 * import { YaGeocoderService } from 'angular8-yandex-maps';
 *
 * @Component()
 * export class AppComponent {
 *   constructor(private yaGeocoderService: YaGeocoderService) {
 *     // Don't forget to unsubscribe
 *     this.yaGeocoderService.geocode('Moscow')
 *       .subscribe(v => console.log(v))
 *   }
 * }
 * ```
 */
export class YaGeocoderService {
    constructor(ngZone, yaApiLoaderService) {
        this.ngZone = ngZone;
        this.yaApiLoaderService = yaApiLoaderService;
    }
    /**
     * Processes geocoding requests.
     * @param request The address for which coordinates need to be obtained (forward geocoding), or the coordinates for which the address needs to be determined (reverse geocoding).
     * @param options Options.
     */
    geocode(request, options) {
        return this.yaApiLoaderService.load().pipe(switchMap(() => from(ymaps.geocode(request, options))), switchMap((result) => new Observable((observer) => {
            this.ngZone.run(() => {
                observer.next(result);
                observer.complete();
            });
        })));
    }
}
YaGeocoderService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.5", ngImport: i0, type: YaGeocoderService, deps: [{ token: i0.NgZone }, { token: i1.YaApiLoaderService }], target: i0.ɵɵFactoryTarget.Injectable });
YaGeocoderService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.5", ngImport: i0, type: YaGeocoderService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.5", ngImport: i0, type: YaGeocoderService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i1.YaApiLoaderService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWEtZ2VvY29kZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXI4LXlhbmRleC1tYXBzL3NyYy9saWIvc2VydmljZXMveWEtZ2VvY29kZXIveWEtZ2VvY29kZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFVLE1BQU0sZUFBZSxDQUFDO0FBQ25ELE9BQU8sRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3hDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7O0FBSTNDOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JHO0FBSUgsTUFBTSxPQUFPLGlCQUFpQjtJQUM1QixZQUNtQixNQUFjLEVBQ2Qsa0JBQXNDO1FBRHRDLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDZCx1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW9CO0lBQ3RELENBQUM7SUFFSjs7OztPQUlHO0lBQ0gsT0FBTyxDQUFDLE9BQTBCLEVBQUUsT0FBK0I7UUFDakUsT0FBTyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUN4QyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFDdEQsU0FBUyxDQUNQLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FDVCxJQUFJLFVBQVUsQ0FBUyxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQ2xDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRTtnQkFDbkIsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDdEIsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ3RCLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQ0wsQ0FDRixDQUFDO0lBQ0osQ0FBQzs7OEdBeEJVLGlCQUFpQjtrSEFBakIsaUJBQWlCLGNBRmhCLE1BQU07MkZBRVAsaUJBQWlCO2tCQUg3QixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBmcm9tLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7IFlhQXBpTG9hZGVyU2VydmljZSB9IGZyb20gJy4uL3lhLWFwaS1sb2FkZXIveWEtYXBpLWxvYWRlci5zZXJ2aWNlJztcclxuXHJcbi8qKlxyXG4gKiBUaGUgYFlhR2VvY29kZXJgIHNlcnZpY2Ugd3JhcHMgYHltYXBzLmdlb2NvZGVgIHN0YXRpYyBmdW5jdGlvbiBmcm9tIHRoZSBZYW5kZXguTWFwcyBBUEkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHRzXHJcbiAqIGltcG9ydCB7IFlhR2VvY29kZXJTZXJ2aWNlIH0gZnJvbSAnYW5ndWxhcjgteWFuZGV4LW1hcHMnO1xyXG4gKlxyXG4gKiBAQ29tcG9uZW50KClcclxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XHJcbiAqICAgY29uc3RydWN0b3IocHJpdmF0ZSB5YUdlb2NvZGVyU2VydmljZTogWWFHZW9jb2RlclNlcnZpY2UpIHtcclxuICogICAgIC8vIERvbid0IGZvcmdldCB0byB1bnN1YnNjcmliZVxyXG4gKiAgICAgdGhpcy55YUdlb2NvZGVyU2VydmljZS5nZW9jb2RlKCdNb3Njb3cnKVxyXG4gKiAgICAgICAuc3Vic2NyaWJlKHYgPT4gY29uc29sZS5sb2codikpXHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuQEluamVjdGFibGUoe1xyXG4gIHByb3ZpZGVkSW46ICdyb290JyxcclxufSlcclxuZXhwb3J0IGNsYXNzIFlhR2VvY29kZXJTZXJ2aWNlIHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgbmdab25lOiBOZ1pvbmUsXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IHlhQXBpTG9hZGVyU2VydmljZTogWWFBcGlMb2FkZXJTZXJ2aWNlLFxyXG4gICkge31cclxuXHJcbiAgLyoqXHJcbiAgICogUHJvY2Vzc2VzIGdlb2NvZGluZyByZXF1ZXN0cy5cclxuICAgKiBAcGFyYW0gcmVxdWVzdCBUaGUgYWRkcmVzcyBmb3Igd2hpY2ggY29vcmRpbmF0ZXMgbmVlZCB0byBiZSBvYnRhaW5lZCAoZm9yd2FyZCBnZW9jb2RpbmcpLCBvciB0aGUgY29vcmRpbmF0ZXMgZm9yIHdoaWNoIHRoZSBhZGRyZXNzIG5lZWRzIHRvIGJlIGRldGVybWluZWQgKHJldmVyc2UgZ2VvY29kaW5nKS5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zLlxyXG4gICAqL1xyXG4gIGdlb2NvZGUocmVxdWVzdDogc3RyaW5nIHwgbnVtYmVyW10sIG9wdGlvbnM/OiB5bWFwcy5JR2VvY29kZU9wdGlvbnMpOiBPYnNlcnZhYmxlPG9iamVjdD4ge1xyXG4gICAgcmV0dXJuIHRoaXMueWFBcGlMb2FkZXJTZXJ2aWNlLmxvYWQoKS5waXBlKFxyXG4gICAgICBzd2l0Y2hNYXAoKCkgPT4gZnJvbSh5bWFwcy5nZW9jb2RlKHJlcXVlc3QsIG9wdGlvbnMpKSksXHJcbiAgICAgIHN3aXRjaE1hcChcclxuICAgICAgICAocmVzdWx0KSA9PlxyXG4gICAgICAgICAgbmV3IE9ic2VydmFibGU8b2JqZWN0Pigob2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcclxuICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgKSxcclxuICAgICk7XHJcbiAgfVxyXG59XHJcbiJdfQ==